.\"     Title: pam_conv
.\"    Author: 
.\" Generator: DocBook XSL Stylesheets v1.70.1 <http://docbook.sf.net/>
.\"      Date: 06/27/2006
.\"    Manual: Linux\-PAM Manual
.\"    Source: Linux\-PAM Manual
.\"
.TH "PAM_CONV" "3" "06/27/2006" "Linux\-PAM Manual" "Linux\-PAM Manual"
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.SH "NAME"
pam_conv \- PAM conversation function
.SH "SYNOPSIS"
.sp
.ft B
.nf
#include <security/pam_appl.h>
.fi
.ft
.sp
.RS 3n
.nf
struct pam_message {
    int msg_style;
    const char *msg;
};

struct pam_response {
    char *resp;
    int resp_retcode;
};

struct pam_conv {
    int (*conv)(int num_msg, const struct pam_message **msg,
                struct pam_response **resp, void *appdata_ptr);
    void *appdata_ptr;
};
    
.fi
.RE
.SH "DESCRIPTION"
.PP
The PAM library uses an application\-defined callback to allow a direct communication between a loaded module and the application. This callback is specified by the
\fIstruct pam_conv\fR
passed to
\fBpam_start\fR(3)
at the start of the transaction.
.PP
When a module calls the referenced conv() function, the argument
\fIappdata_ptr\fR
is set to the second element of this structure.
.PP
The other arguments of a call to conv() concern the information exchanged by module and application. That is to say,
\fInum_msg\fR
holds the length of the array of pointers,
\fImsg\fR. After a successful return, the pointer
\fIresp\fR
points to an array of pam_response structures, holding the application supplied text. The
\fIresp_retcode\fR
member of this struct is unused and should be set to zero. It is the caller's responsibility to release both, this array and the responses themselves, using
\fBfree\fR(3). Note,
\fI*resp\fR
is a
\fIstruct pam_response\fR
array and not an array of pointers.
.PP
The number of responses is always equal to the
\fInum_msg\fR
conversation function argument. This does require that the response array is
\fBfree\fR(3)'d after every call to the conversation function. The index of the responses corresponds directly to the prompt index in the pam_message array.
.PP
On failure, the conversation function should release any resources it has allocated, and return one of the predefined PAM error codes.
.PP
Each message can have one of four types, specified by the
\fImsg_style\fR
member of
\fIstruct pam_message\fR:
.TP 3n
PAM_PROMPT_ECHO_OFF
Obtain a string without echoing any text.
.TP 3n
PAM_PROMPT_ECHO_ON
Obtain a string whilst echoing text.
.TP 3n
PAM_ERROR_MSG
Display an error message.
.TP 3n
PAM_TEXT_INFO
Display some text.
.PP
The point of having an array of messages is that it becomes possible to pass a number of things to the application in a single call from the module. It can also be convenient for the application that related things come at once: a windows based application can then present a single form with many messages/prompts on at once.
.PP
In passing, it is worth noting that there is a descrepency between the way Linux\-PAM handles the const struct pam_message **msg conversation function argument from the way that Solaris' PAM (and derivitives, known to include HP/UX, are there others?) does. Linux\-PAM interprets the msg argument as entirely equivalent to the following prototype const struct pam_message *msg[] (which, in spirit, is consistent with the commonly used prototypes for argv argument to the familiar main() function: char **argv; and char *argv[]). Said another way Linux\-PAM interprets the msg argument as a pointer to an array of num_meg read only 'struct pam_message' pointers. Solaris' PAM implementation interprets this argument as a pointer to a pointer to an array of num_meg pam_message structures. Fortunately, perhaps, for most module/application developers when num_msg has a value of one these two definitions are entirely equivalent. Unfortunately, casually raising this number to two has led to unanticipated compatibility problems.
.PP
For what its worth the two known module writer work\-arounds for trying to maintain source level compatibility with both PAM implementations are:
.TP 3n
\(bu
never call the conversation function with num_msg greater than one.
.TP 3n
\(bu
set up msg as doubly referenced so both types of conversation function can find the messages. That is, make
.sp
.RS 3n
.nf
       msg[n] = & (( *msg )[n])
       
.fi
.RE
.SH "RETURN VALUES"
.TP 3n
PAM_BUF_ERR
Memory buffer error.
.TP 3n
PAM_CONV_ERR
Conversation failure. The application should not set
\fI*resp\fR.
.TP 3n
PAM_SUCCESS
Success.
.SH "SEE ALSO"
.PP

\fBpam_start\fR(3),
\fBpam_set_item\fR(3),
\fBpam_get_item\fR(3),
\fBpam_strerror\fR(3),
\fBpam\fR(8)
